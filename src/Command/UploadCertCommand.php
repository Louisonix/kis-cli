<?php
/**
 * This file is part of the kis-cli package.
 *
 * (c) Ole Loots <ole@monochrom.net>
 *
 * For the full license information, please view the LICENSE
 * file that was distributed with this source code.
 */


namespace Mono\KisCLI\Command;

use Psr\Log\LoggerInterface;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Exception\InvalidArgumentException;
use Symfony\Component\Console\Input\InputOption;


/***
 * Upload TLS certs to Hosteurope 
 */
#[AsCommand(
	name: 'kis:upload-cert',
	description: "Upload TLS cert files to hosteurope. Invoked without options, the last cert generated by acme:verify is uploaded.",
	hidden: false,
)]
class UploadCertCommand extends HostEuropeBaseCommand
{
	/**
	 * 
	 * @param LoggerInterface $logger 
	 * @return void 
	 * @throws InvalidArgumentException 
	 */
	public function __construct(protected LoggerInterface $logger)
	{
		parent::__construct($logger);
	}

	protected function configure(): void
	{
		parent::configure();

		$this->addOption('keyfile', null, InputOption::VALUE_REQUIRED, 'Specfiy the keyfile to upload (if not specified, the last keyfile generated by hosteurope:acme:verify) is used.', null);
		$this->addOption('fullchain', null, InputOption::VALUE_REQUIRED, 'Specfiy the fullchain certificate to upload (if not specified, the last certificate generated by hosteurope:acme:verify) is used.', null);
		$this->addOption('webpack-id', null, InputOption::VALUE_REQUIRED, 'Specify the contract (webpack id) which is used for cert upload (use hosteuroe:list-webpacks to list available packages for your contract)');
		$this->addOption('vhosts', null, InputOption::VALUE_OPTIONAL, 'Specify vhosts ids used for cert upload by comma separated list, example: default,1234,1235. Default: * (any vhost found)', '*');
	}

	protected function execute(InputInterface $input, OutputInterface $output): int
	{

		$uploadInfo = null;
		$result = parent::execute($input, $output);

		if ($result != Command::SUCCESS) {
			print_r($result);
			return $result;
		}

		if ($input->getOption('webpack-id') == false) {
			$output->writeln("Error: contract/webpack id is required for cert upload.");
			return Command::FAILURE;
		}

		if (($input->getOption('keyfile') == null) != ($input->getOption('fullchain') == null)) {
			$output->writeln("When manually specifing files to upload, both files (key and fullchain) must be specified!");
			$result = Command::INVALID;
		}

		if ($input->getOption('keyfile') == false && $input->getOption('fullchain') == false) {
			$uploadInfo = $this->getPendingUploadsInfo();
			if (!$this->isValidCertUploadInfo($uploadInfo)) {
				$logContents = explode("\n", file_get_contents($this->getAcmeShFolder() . 'acme.sh.log'));
				$uploadInfo = $this->parseAcmeRenewOutput($input, $output, $logContents);
				if (!$this->isValidCertUploadInfo($uploadInfo)) {
					$output->writeln("Couldn't detect valid files for upload. ");
					$result = Command::FAILURE;
				}
			}
		} else {

			$keyfile = $input->getOption('keyfile');
			$fullchain = $input->getOption('fullchain');

			$uploadInfo = [
				'key' => $keyfile,
				'fullchain' => $fullchain
			];

			if (!file_exists($uploadInfo['key'])) {
				$output->writeln('Keyfile ' . $uploadInfo['key'] . ' doesn\'t exist!');
				$result = Command::FAILURE;
			}

			if (!file_exists($uploadInfo['fullchain'])) {
				$output->writeln('Fullchain cert (' . $uploadInfo['fullchain'] . ') doesn\'t exist!');
				$result = Command::FAILURE;
			}
		}



		if ($result == Command::SUCCESS && $this->isValidCertUploadInfo($uploadInfo)) {

			$output->writeln("Certficate available:");
			$output->writeln('keyfile: ' . $uploadInfo['key'], OutputInterface::VERBOSITY_NORMAL);
			$output->writeln('fullchain: ' . $uploadInfo['fullchain'], OutputInterface::VERBOSITY_NORMAL);

			$output->writeln('Uploading Certificate ...');

			// loop: schauen, für welche domains ein vhost existiert
			// upload für match -> vhost id merken
			// solange, bis alle domains durch sind
			// upload aber nur durchführen, wenn vhost-id noch nicht in der "done" liste ist

			$inVhostsAsArray = explode(",", $input->getOption('vhosts'));
			$this->initKisSession($output, $input);
			$endpointsTab = $this->listSSLEndpoints($input, $output, $input->getOption('webpack-id'));
			$vhostsDone = [];
			foreach ($endpointsTab as $ep) {
				if (count($ep['domains']) == 1 && $ep['domains'][0] == '- keine Domains zugeordnet -') {
					continue;
				}
				if (!empty($ep['vid']) && $ep['vid'] == 'default') {
					if (in_array('*', $inVhostsAsArray) || in_array('default', $inVhostsAsArray)) {
						$output->writeln("Uploading cert to default vhost ...");
						$tmpResult = $this->uploadCert($input, $output, $ep, $uploadInfo['fullchain'], $uploadInfo['key']);
						if (strpos($tmpResult, 'Die Dateien wurden erfolgreich hochgeladen.') === false) {
							$output->writeln("Unexpected upload result! Expecting upload failure!", OutputInterface::VERBOSITY_NORMAL);
							$result = Command::FAILURE;
						} else {
							$output->writeln("Upload success. Waiting for redirect...");
							// wait until redirect happens (otherwise the redirect interferes with subsequent browser replay scripts)
							$this->getClient()->replayJSON([
								"steps" => [
									[
										"type" => "customStep",
										"name" => "waitForUrl",
										"url" => "https://kis.hosteurope.de/administration/webhosting/",
										"timeout" => 30
									]
								]
							]);
							$output->writeln("done");
							$vhostsDone[] = $ep['vid'];
						}
						// TODO: check upload success somehow? Or use sslscan to verify results 								
					}
				}
				if (!empty($ep['vid']) && intval($ep['vid']) > 0) {
					// TODO: populate domains array when not passed as commandline option
					$domains = $this->fetchDomainsFromKis(); // TODO: cache
					foreach ($domains as $domain) {
						if (in_array($domain, $ep['domains']) && !in_array($ep['vid'], $vhostsDone)) {
							$output->writeln("Uploading cert to vhost " . $ep['vid'] . " ... ");
							$tmpResult = $this->uploadCert($input, $output, $ep, $uploadInfo['fullchain'], $uploadInfo['key']);
							if (strpos($tmpResult, 'Die Dateien wurden erfolgreich hochgeladen.') === false) {
								$output->writeln("Unexpected upload result! Expecting upload failure!", OutputInterface::VERBOSITY_NORMAL);
								$result = Command::FAILURE;
							} else {
								$output->writeln("Upload success. Waiting for redirect...");
								// wait until redirect happens
								$this->getClient()->replayJSON([
									"steps" => [
										[
											"type" => "customStep",
											"name" => "waitForUrl",
											"url" => "https://kis.hosteurope.de/administration/webhosting/",
											"timeout" => 30
										]
									]
								]);
								$output->writeln("done");
								$vhostsDone[] = $ep['vid'];
							}
							// TODO: check upload success somehow or use sslscan to verify results 	
						}
					}
				}
			}
		}

		return $result;


		// this method must return an integer number with the "exit status code"
		// of the command. You can also use these constants to make code more readable

		// return this if there was no problem running the command
		// (it's equivalent to returning int(0))
		//return Command::SUCCESS;

		// or return this if some error happened during the execution
		// (it's equivalent to returning int(1))
		// return Command::FAILURE;

		// or return this to indicate incorrect command usage; e.g. invalid options
		// or missing arguments (it's equivalent to returning int(2))
		// return Command::INVALID
	}
}
